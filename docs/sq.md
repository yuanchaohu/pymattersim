### Structure Factors

The class `static.sq.sq` calculates the overall, partial or conditional structure factor $S(q)$ in orthogonal cells at various dimensional systems directly. This module is suitable for multi-component systems, from unary to quinary. In principal, $S(q)$ is defined as:

$$
\rho({\vec q}) = \sum_j^{N} \exp(-i {\vec q} \cdot {\vec r_j})
$$

$$
S({\vec q}) = \frac{1}{N} \left< \rho({\vec q}) \rho({{-\vec q}}) \right>
$$

$\rho({\vec q})$ is the spatial Fourier transformation of the number density. $\vec q$ is wavevector, in three dimensions, defined as 

$$
\vec q = [\frac{2\pi}{L_x} n_x, \frac{2\pi}{L_y} n_y, \frac{2\pi}{L_z} n_z],
$$

where $L_x$, $L_y$, $L_z$, are box lengths, and $n_x$, $n_y$, $n_z$ are integers. $S(q)$ can be calculated for specified wavevector(s) or for designed wavevector(s) from the method `utils.wavevector`. $\vec r_i$ is particle position.

In general, the definition of $S(q)$ is easily extended for conditional particles. That is, particles with specific properties. For example, let's assume the particle-level property for atom $i$ is $A_i$.
In this way, $S(q)$ can be broadly defined as

$$
\rho_\alpha ({\vec q}) = \frac{1}{\sqrt{N_\alpha}} \sum_i^{N_\alpha} A_i \exp(-i {\vec q} \cdot {\vec r_i})
$$

$$
S_{\alpha\beta}({\vec q}) = \left< \rho_\alpha({\vec q}) \rho_\beta({-\vec q})) \right>
$$

$\rho_\alpha ({\vec q})$ can be treated as the fourier-transform of $A_i$, meanwhile $N_\alpha$ is the particle number with a true $A_i$ value. A straightforward example is the structure factor $S(q)$ among different atom types $\alpha$ and $\beta$ for a binary system. In this case, for $\rho_\alpha ({\vec q})$, $A_i = True$ for $\alpha$-type atoms and =False for others, similarly for $\beta$-type. The partial structure factors $S_{\alpha\alpha}(q)$, $S_{\alpha\beta}(q)$, and $S_{\beta\beta}(q)$ can be calcualted.

In addition, we design `static.sq.conditional_sq` to calculate the structure factor and FFT of a single configuration for particles with conditional propties, as demonstrated from the above formula. There are three cases considered for $A_i$:

- `condition` is bool type, so calculate S(q) & FFT for selected particles. For example, for $S_{\alpha\alpha}(q)$ and $S_{\beta\beta}(q)$, but not for $S_{\alpha\beta}(q)$.
- `condition` is float vector type, so calculate spectral & FFT of vector quantity; such as velocity field
- `condition` is float scalar type, so calculate spectral & FFT of scalar quantity; such as structural ordering


##### 1. `sq` class

**Input Arguments**
- `snapshots` (`reader.reader_utils.Snapshots`): `Snapshots` data class returned by `reader.dump_reader.DumpReader` from input configuration file
- `qrange` (`float`): the wave number range to be calculated, default 10.0
- `onlypositive` (`bool`): whether only consider positive wave vectors, default `False`
- `qvector` (`npt.NDArray`): input wavevectors in two-dimensional `npt.NDArray`, if `None` (default) use qrange & onlypositive (call `utils.wavevector` to generate wavevectors)
- `saveqvectors` (`bool`): whether to save ***S(q)*** for specific wavevectors, default `False`
- `outputfile` (`str`): the name of csv file to save the ensemble- and direction-average ***S(q)***, default `None`

**Example**

```python
from reader.dump_reader import DumpReader
from reader.reader_utils import DumpFileType
from static.sq import sq

filename = 'dump.atom'
readdump = DumpReader(filename, ndim=3, filetype=DumpFileType.LAMMPS, moltypes=None)
readdump.read_onefile()

sq_cal=sq(readdump.snapshots, outputfile='sq.csv')
```

##### `getresults()`
`getresults()` method is used to to determine which function to call for calculating $S(q)$ based on the component (automatic).

**Input Arguments**
`None`

**Example**
```python
sq_cal.getresults()
```

**Return**
`Optional[Callable]`. For the sytem with one particle type, calling `self.unary()` function to calculate $S(q)$, also including `self.binary()`, `self.ternary()`, `self.quarternary`, `self.quinary` for binary, ternary, quarternary, and quinary systems. For systems with more than five components, only overall $S(q)$ will be calcuated by calling `self.unary()` function.

The calculated $S(q)$ is storted in the `outputfile`. Taken ternary sytem as an example, each column in `outputfile` is "*q, Sq, Sq11, Sq22, Sq33, Sq12, Sq13, Sq23*".

##### 2. `conditional_sq()`

**Input Arguments**
- `snapshot` (`reader.reader_utils.SingleSnapshot`): single snapshot object of input trajectory
- `qvector` (`npt.NDArray` of int): input wavevectors in two-dimensional `npt.NDArray`. `qvector` can also be generated by calling `utils.wavevector`.
- `condition` (`npt.NDArray`): particle-level condition/property

**Return**
- `sqresults` (`pd.DataFrame`): calculated conditional $S(q)$ for each input wavevector [FFT in complex number is also returned for reference] 
- `ave_sqresults` (`pd.DataFrame`): the ensemble averaged $S(q)$ over the same wavenumber

Note that this calculation is only for single snapshot.

**Example**
```python
from static.sq import conditional_sq
from utils.wavevector import choosewavevector

qrange = 10.0
for snapshot in readdump.snapshots.snapshots:
    twopidl = 2*np.pi / snapshot.boxlength
    numofq = int(qrange*2.0/twopidl.min())
    qvector = choosewavevector(ndim=3, numofq=numofq, onlypositive=False)
    
    ### Select particles with a particle type of 2 for S(q) calculation
    sqresults_selection = conditional_sq(
        snapshot, 
        qvector=qvector,
        condition=snapshot.particle_type==2
    )
    
    ### Randomly generating values for particle quantity, ranging from 0 to 1
    particle_quantity = np.random.rand(snapshot.nparticle)

    ### particle level quantity as conditoin to calculate S(q), also support complex-number quantity
    sqresults, sqresults_ave = conditional_sq(
        snapshot, 
        qvector=qvector, 
        condition=particle_quantity
    )
```